#
# Board
#

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

#
# esphome core
#

external_components:
  - source:
      type: local
      path: mycomponents

esphome:
  name: ant
  name_add_mac_suffix: true
  includes:
    - ../src-common
  on_boot:
    - then:
        lambda: |-
          id(siren).turn_on();
          id(siren).set_level(0);
          id(buzzer).turn_on();
          id(buzzer).set_level(0);
          antg.action_set_siren_level(id(g_siren_level), false);
  on_shutdown:
    - then:
        lambda: |-
          id(siren).turn_off();
          id(buzzer).turn_off();

logger:
  level: DEBUG

preferences:
  flash_write_interval: 10s

mdns:
  disabled: true

#
# OTA config
#

wifi:
  id: mywifi
  enable_on_boot: false

  ap:
    password: 100decibel
    ap_timeout: 10s

ota:
  - platform: web_server
    on_begin:
      then:
        - lambda: |-
            id(my_display).print(0, 0, "    Updating    ");
            id(my_display).print(0, 1, "    firmware    ");
    on_error:
      then:
        - lambda: |-
            id(my_display).print(0, 0,  "    Updating    ");
            id(my_display).printf(0, 1, "   Error %d    ", x);

web_server:
  port: 80
  index_html_include: ./index.html

#
# Prop hardware
#

globals:
  - id: g_siren_level # 1-9
    type: int
    restore_value: true
    initial_value: "9"

output:
  - platform: ledc
    pin: GPIO1
    id: buzzer
    frequency: 1000Hz

  - platform: ledc
    pin: GPIO10
    id: siren

binary_sensor:
  # RED button
  - platform: gpio
    pin: GPIO3
    id: btn_r
    filters:
      - invert:
    on_press:
      lambda: |-
        ESP_LOGI("Key", "on_press RED");
        game_manager.handle_key(KEY_RED);
        id(my_display).update();
    on_release:
      lambda: |-
        ESP_LOGI("Key", "on_release RED");
        game_manager.handle_key(KEY_RED_RELEASE);
        id(my_display).update();

  # YELLOW button
  - platform: gpio
    pin: GPIO4
    id: btn_y
    filters:
      - invert:
    on_press:
      lambda: |-
        ESP_LOGI("Key", "on_press YELLOW");
        game_manager.handle_key(KEY_YELLOW);
        id(my_display).update();
    on_release:
      lambda: |-
        ESP_LOGI("Key", "on_release YELLOW");
        game_manager.handle_key(KEY_YELLOW_RELEASE);
        id(my_display).update();

  # C long press handling for game restart
  - platform: matrix_keypad
    keypad_id: mykeypad
    id: key_c
    key: C
    on_press:
      lambda: |-
        game_manager.key_c_press_at = millis();
    on_release:
      lambda: |-
        game_manager.key_c_press_at = 0;

  # D long press handling for organizer game reset
  - platform: matrix_keypad
    keypad_id: mykeypad
    id: key_d
    key: D
    on_press:
      lambda: |-
        game_manager.hard_reset_press_at = millis();
    on_release:
      lambda: |-
        game_manager.hard_reset_press_at = 0;

  # * long press handling for organizer game reset
  - platform: matrix_keypad
    keypad_id: mykeypad
    id: key_star
    key: "*"
    on_press:
      lambda: |-
        game_manager.hard_reset_press_at = millis();
    on_release:
      lambda: |-
        game_manager.hard_reset_press_at = 0;

matrix_keypad:
  id: mykeypad
  rows:
    - pin:
        pcf8574: pcf8574_hub
        number: 0
    - pin:
        pcf8574: pcf8574_hub
        number: 1
    - pin:
        pcf8574: pcf8574_hub
        number: 2
    - pin:
        pcf8574: pcf8574_hub
        number: 3
  columns:
    - pin:
        pcf8574: pcf8574_hub
        number: 4
    - pin:
        pcf8574: pcf8574_hub
        number: 5
    - pin:
        pcf8574: pcf8574_hub
        number: 6
    - pin:
        pcf8574: pcf8574_hub
        number: 7
  keys: "D#0*C987B654A321"
  has_diodes: false
  on_key:
    - lambda: |-
        ESP_LOGI("Key", "on_key %c", x);
        game_manager.handle_key(x);
        id(my_display).update();

i2c:
  - id: bus_a
    sda: GPIO8
    scl: GPIO9
    frequency: 300kHz

pcf8574:
  - id: "pcf8574_hub"
    address: 0x20
    pcf8575: false

display:
  - platform: lcd_pcf8574
    id: my_display
    i2c_id: bus_a
    dimensions: 16x2
    address: 0x21
    # update_interval: never
    user_characters:
      # right arrow
      - position: 0
        data:
          - 0b11000
          - 0b01100
          - 0b00110
          - 0b11111
          - 0b11111
          - 0b00110
          - 0b01100
          - 0b11000
      # progress bars
      - position: 1
        data:
          - 0b10000
          - 0b10000
          - 0b10000
          - 0b10000
          - 0b10000
          - 0b10000
          - 0b10000
          - 0b10000
      - position: 2
        data:
          - 0b11000
          - 0b11000
          - 0b11000
          - 0b11000
          - 0b11000
          - 0b11000
          - 0b11000
          - 0b11000
      - position: 3
        data:
          - 0b11100
          - 0b11100
          - 0b11100
          - 0b11100
          - 0b11100
          - 0b11100
          - 0b11100
          - 0b11100
      - position: 4
        data:
          - 0b11110
          - 0b11110
          - 0b11110
          - 0b11110
          - 0b11110
          - 0b11110
          - 0b11110
          - 0b11110
      - position: 5
        data:
          - 0b11111
          - 0b11111
          - 0b11111
          - 0b11111
          - 0b11111
          - 0b11111
          - 0b11111
          - 0b11111
    lambda: |-
      game_manager.display_update(it);

script:
  - id: s_start_buzzer
    parameters:
      duration: int
      level: float
      tone: int
    mode: single
    then:
      - output.ledc.set_frequency:
          id: buzzer
          frequency: !lambda return tone;
      - output.set_level:
          id: buzzer
          level: !lambda return level;
      - delay: !lambda return duration;
      - output.set_level:
          id: buzzer
          level: 0

  - id: s_start_siren
    parameters:
      delay: int
      duration: int
      level: float
      tone: int
    mode: restart
    then:
      - delay: !lambda return delay;
      - output.ledc.set_frequency:
          id: siren
          frequency: !lambda return tone;
      - output.set_level:
          id: siren
          level: !lambda return level;
      - delay: !lambda return duration;
      - output.set_level:
          id: siren
          level: 0

  - id: s_stop_siren
    then:
      - output.set_level:
          id: siren
          level: 0

  - id: s_start_ota
    then:
      lambda: |-
        id(mywifi).enable();
        antg.ota_info.ssid = wifi::global_wifi_component->get_ap().get_ssid();
        antg.ota_info.psk = wifi::global_wifi_component->get_ap().get_password();
        antg.ota_info.ip = wifi::global_wifi_component->wifi_soft_ap_ip().str();

  - id: s_stop_ota
    then:
      lambda: |-
        id(mywifi).disable();

  - id: s_handle_actions
    then:
      lambda: |-
        uint32_t actions = antg.actions;
        if (actions > 0) {
          if (actions & ACTION_SAVE_SIREN_LEVEL) {
            id(g_siren_level) = antg.settings.siren_level_user;
          }
          if (actions & ACTION_START_SIREN) {
            ant_siren_t *s = &antg.siren_params;
            id(s_start_siren)->execute(s->delay, s->duration, s->level, s->tone);
          }
          if (actions & ACTION_STOP_SIREN) {
            id(s_stop_siren)->execute();
          }
          if (actions & ACTION_START_BUZZER) {
            ant_buzzer_t *b = &antg.buzzer_params;
            id(s_start_buzzer)->execute(b->duration, b->level, b->tone);
          }
          if (actions & ACTION_START_OTA) {
            id(s_start_ota)->execute();
          }
          if (actions & ACTION_STOP_OTA) {
            id(s_stop_ota)->execute();
          }
        }

interval:
  - interval: 50ms
    then:
      - lambda: |-
          uint32_t now = millis();
          game_manager.clock(now, now - game_manager.clock_last_update_ms);
          id(my_display).update();
